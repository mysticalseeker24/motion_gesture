import os
import time
import shutil
from pathlib import Path
from config.config import TTS_OUTPUT_DIR

class AudioManager:
    """Manages audio files generated by the TTS system
    
    Handles clean-up, caching, and efficient storage of audio files.
    """
    
    def __init__(self, max_files=100, max_age_days=7):
        self.output_dir = TTS_OUTPUT_DIR
        self.max_files = max_files
        self.max_age_seconds = max_age_days * 24 * 60 * 60
        
        # Create directory if it doesn't exist
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Initialize cache for frequent responses
        self.response_cache = {}
    
    def get_audio_path(self, text):
        """Get path to audio file for the given text, using cache if available"""
        # Check if we already have this text cached
        if text in self.response_cache and os.path.exists(self.response_cache[text]):
            return self.response_cache[text]
        return None
    
    def save_audio(self, text, audio_path):
        """Save audio file path to cache"""
        self.response_cache[text] = audio_path
        
        # Clean up old files if needed
        self._cleanup_old_files()
        
        return audio_path
    
    def get_audio_url(self, audio_path):
        """Convert file path to URL accessible by frontend"""
        if not audio_path or not os.path.exists(audio_path):
            return None
            
        # Get the relative path from the output directory
        rel_path = os.path.relpath(audio_path, self.output_dir)
        
        # Return the URL path that can be accessed through the API
        return f"/audio/{rel_path}"
    
    def _cleanup_old_files(self):
        """Remove old audio files to prevent storage bloat"""
        try:
            # Get all files in the directory
            audio_files = list(Path(self.output_dir).glob("*.mp3"))
            
            # If we're under the limit, no need to clean up
            if len(audio_files) <= self.max_files:
                return
                
            # Get file stats and sort by modification time
            file_stats = [(f, os.path.getmtime(f)) for f in audio_files]
            file_stats.sort(key=lambda x: x[1])  # Sort by modification time
            
            # Current time
            current_time = time.time()
            
            # Clean up files exceeding max count or old files
            for file_path, mtime in file_stats:
                # Skip files used in cache
                if str(file_path) in self.response_cache.values():
                    continue
                    
                # Remove if too old
                if current_time - mtime > self.max_age_seconds:
                    os.remove(file_path)
                    continue
                    
                # If we're still over the limit, remove oldest files
                if len(audio_files) > self.max_files:
                    os.remove(file_path)
                    audio_files.remove(file_path)
        except Exception as e:
            print(f"Error cleaning up audio files: {e}")
    
    def clear_all(self):
        """Remove all audio files except those in active cache"""
        try:
            # Get all files in the directory
            audio_files = list(Path(self.output_dir).glob("*.mp3"))
            
            # Remove files not in cache
            for file_path in audio_files:
                if str(file_path) not in self.response_cache.values():
                    os.remove(file_path)
        except Exception as e:
            print(f"Error clearing audio files: {e}")

# Singleton instance
audio_manager = AudioManager()
